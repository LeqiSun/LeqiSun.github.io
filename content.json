[{"title":"ConcurrentHashMap，synchronizedMap分析比较","date":"2016-10-20T12:00:00.000Z","path":"java/ConcurrentHashMap/","text":"多线程情况下使用Map集合时，不能使用常用的HashMap，因为HashMap不是线程安全类，这里就要使用线程安全的Map实现类，当然我们首选ConcurrentHashMap。 Map的线程安全实现方式有三种，分别为Hashtable、Collections.synchronizedMap和ConcurrentHashMap HashtableHashtable的效率比较差，因为它是在方法上使用synchronized来保证线程安全，粒度比较粗，当有多个线程激烈竞争时，效率非常低下，当一个线程访问Hashtable的同步方法时，其它线程访问Hashtable的同步方法会进入阻塞状态，即当某一个线程添加元素时，其他线程不能添加元素，或是get元素，如果并发量大的话，效率会非常低下，所以不推荐使用。 synchronizedMapsynchronizedMap是Collections的内部类，它的线程安全实现方式跟Hashtable比较像，粒度也很粗，使用了一个互斥变量，对其加锁进行控制，性能和Hashtable基本一样，所以也不推荐1234567public V get(Object key) &#123; synchronized (mutex) &#123;return m.get(key);&#125;&#125;public V put(K key, V value) &#123; synchronized (mutex) &#123;return m.put(key, value);&#125;&#125; ConcurrentHashMap更好的选择是ConcurrentHashMap，它是在jdk1.5里添加的，它使用了一种完全不同的加锁策略来提供更高的并发性和伸缩性，ConcurrentHashMap并不是将每个方法都在同一个锁上同步并使得每次只能有一个线程访问容器，而是使用一种粒度更细的加锁机制来实现更程度的共享，在JDK8之前使用的是Segment分段锁机制，JDK8使用的是CAS（Compare And Swap）和Synchronized来保证并发更新的安全，可以看看JDK8里的部分代码Node Table初始化123456789101112131415161718192021private final Node&lt;K,V&gt;[] initTable() &#123; Node&lt;K,V&gt;[] tab; int sc; while ((tab = table) == null || tab.length == 0) &#123; if ((sc = sizeCtl) &lt; 0) Thread.yield(); // lost initialization race; just spin else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; try &#123; if ((tab = table) == null || tab.length == 0) &#123; int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY; Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n]; table = tab = nt; sc = n - (n &gt;&gt;&gt; 2); &#125; &#125; finally &#123; sizeCtl = sc; &#125; break; &#125; &#125; return tab;&#125; 可以看到，在初始化table时，使用的是CAS机制，可以看到有一个变量sizeCtl，初始化的值是0，当小于0时，表明有其它线程正在操作table，所以执行Thread.yield()让出CPU时间片，然后只会有一个线程能修改sizeCtl成-1并且进行table初始化，这样就能保证table的安全初始化。 put操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123; return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);&#125;static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123; return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);&#125;final V putVal(K key, V value, boolean onlyIfAbsent) &#123; if (key == null || value == null) throw new NullPointerException(); int hash = spread(key.hashCode()); int binCount = 0; for (Node&lt;K,V&gt;[] tab = table;;) &#123; Node&lt;K,V&gt; f; int n, i, fh; if (tab == null || (n = tab.length) == 0) tab = initTable(); else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin &#125; else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else &#123; V oldVal = null; synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; if (fh &gt;= 0) &#123; binCount = 1; for (Node&lt;K,V&gt; e = f;; ++binCount) &#123; K ek; if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; &#125; Node&lt;K,V&gt; pred = e; if ((e = e.next) == null) &#123; pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125; &#125; else if (f instanceof TreeBin) &#123; Node&lt;K,V&gt; p; binCount = 2; if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123; oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; &#125; if (binCount != 0) &#123; if (binCount &gt;= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; &#125; &#125; &#125; addCount(1L, binCount); return null;&#125; 可以看到，在插入一个不存在的key时，使用的也是CAS机制，对于已存在的key，使用synchronized关键字对旧的Node节点加锁，继而进行相关操作 先就到这里，有时间再继续深究一下红黑树，上面就用到了这个。","tags":[{"name":"Java","slug":"Java","permalink":"http://lequsun.com/tags/Java/"},{"name":"Concurrency","slug":"Concurrency","permalink":"http://lequsun.com/tags/Concurrency/"},{"name":"Set","slug":"Set","permalink":"http://lequsun.com/tags/Set/"}]},{"title":"Spring Data JPA中设置实体驼峰类型字段名到数据库下划线类型字段的映射","date":"2016-08-11T13:30:00.000Z","path":"spring/jpa_name_strategy/","text":"最近在新项目中用上了Spring Data JPA，用来替换以前项目用的MyBatis，使用的版本是1.10.2，Hibernate依赖使用的版本是5.2.0 Final。 首先，按照网上搜到的配置基本OK了，项目能启动，以下是实体管理器的xml配置123456789101112131415161718192021&lt;!-- 实体管理器 --&gt;&lt;bean id=\"entityManagerFactory\" class=\"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;property name=\"packagesToScan\" value=\"com.lucas.domain.domain\"/&gt; &lt;property name=\"jpaVendorAdapter\"&gt; &lt;bean class=\"org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter\"/&gt; &lt;/property&gt; &lt;property name=\"jpaDialect\"&gt; &lt;bean class=\"org.springframework.orm.jpa.vendor.HibernateJpaDialect\"/&gt; &lt;/property&gt; &lt;property name=\"jpaProperties\"&gt; &lt;props&gt; &lt;prop key=\"hibernate.show_sql\"&gt;true&lt;/prop&gt; &lt;prop key=\"hibernate.format_sql\"&gt;true&lt;/prop&gt; &lt;prop key=\"hibernate.ejb.naming_strategy\"&gt; com.lucas.strategy.MyImprovedNamingStrategy &lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 自己定义了一个Naming Strategy，MyImprovedNamingStrategy，用于映射Java实体字段名和数据库字段名，但是执行查询时，打印出的Sql并没有按照Naming Strategy来修改，断点也没进，网上查到的资料基本都是说这样写，但是总是没效果，自己在源码里调试，也没调试出个所以然。 几经周折才了解到Hibernate从4升到5要做的修改，其中一点是Naming Strategy接口的修改，已经由ImprovedNamingStrategy替换到PhysicalNamingStrategy了，自己继承了一个实现类后，重写了Column的相关方法，然后重启就启作用了。 但是，这个接口有个问题，对于已经添加了@Column注解并且设置了name的字段，也会进入这个Naming Strategy去处理，假设数据库的某些字段就是驼峰的，那么这个Naming Strategy就没法好好处理了 在这里，Hibernate还提供了一个Naming Strategy的接口，叫做ImplicitNamingStrategy，自己写了个继承，代码如下12345678910111213141516171819202122232425262728import org.apache.commons.lang3.StringUtils;import org.hibernate.boot.model.naming.Identifier;import org.hibernate.boot.model.naming.ImplicitBasicColumnNameSource;import org.hibernate.boot.model.naming.ImplicitNamingStrategyJpaCompliantImpl;/** * 此命名策略不会操作实体内加了@Column注解的字段，PhysicalNamingStrategy的命名策略实现类则会操作 * Created by Lucas on 7/29/2016 */public class MyImplicitNamingStrategy extends ImplicitNamingStrategyJpaCompliantImpl &#123; @Override public Identifier determineBasicColumnName(ImplicitBasicColumnNameSource source) &#123; return convert(source); &#125; private Identifier convert(ImplicitBasicColumnNameSource source) &#123; if (StringUtils.isBlank(transformAttributePath(source.getAttributePath()))) &#123; return toIdentifier(transformAttributePath(source.getAttributePath()), source.getBuildingContext()); &#125; String regex = \"([a-z])([A-Z])\"; String replacement = \"$1_$2\"; String newName = transformAttributePath(source.getAttributePath()) .replaceAll(regex, replacement).toLowerCase(); return toIdentifier(newName, source.getBuildingContext()); &#125;&#125; 实体管理器xml配置修改如下12345678910111213141516171819202122&lt;!-- 实体管理器 --&gt;&lt;bean id=\"entityManagerFactory\" class=\"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;property name=\"packagesToScan\" value=\"com.lucas.domain.domain\"/&gt; &lt;property name=\"jpaVendorAdapter\"&gt; &lt;bean class=\"org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter\"/&gt; &lt;/property&gt; &lt;property name=\"jpaDialect\"&gt; &lt;bean class=\"org.springframework.orm.jpa.vendor.HibernateJpaDialect\"/&gt; &lt;/property&gt; &lt;property name=\"jpaProperties\"&gt; &lt;props&gt; &lt;prop key=\"hibernate.show_sql\"&gt;true&lt;/prop&gt; &lt;prop key=\"hibernate.format_sql\"&gt;true&lt;/prop&gt; &lt;!--注意下面的Naming Strategy的修改--&gt; &lt;prop key=\"hibernate.implicit_naming_strategy\"&gt; com.lucas.strategy.MyImplicitNamingStrategy &lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 这样，就完美解决了字段名的映射问题，普通的字段可以这个Naming Strategy来映射，特殊的字段可以用@Column(name=”数据库里的字段名称”) 另外此Naming Strategy中也可以配置表名的映射等等","tags":[{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"http://lequsun.com/tags/Spring-Data-JPA/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://lequsun.com/tags/Hibernate/"}]},{"title":"使用spring session时，关于session的共享设置","date":"2016-06-05T15:03:00.000Z","path":"spring/java_spring_session/","text":"前些天，针对当前的项目，开了个子项目，准备用个二级域名，要求账号用一套，然后就牵扯到session共享的问题，开始没考虑到spring session，只考虑到tomcat层面的，google了一下后，说配置一下context。 具体是在项目中webapp添加文件夹META-INF，然后添加个文件context.xml，内容为12&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;Context useHttpOnly=\"true\" sessionCookiePath=\"/\" sessionCookieDomain=\".XXXX.com\" /&gt; 但是启动项目后，发现两个地址下的SESSIONID不一样，domain也不一样，然后用户登录信息就不会公用了，后来不管怎么配置都不会生效，让人很苦恼！ 后来了解到我们的项目用的是spring session，所有的用户session都存在redis中了，所以才想到，session的生成逻辑应该是已经被spring session托管了。而后经过大牛的指点，并且看了下spring session的源码，还有spring session中关于session的文档，《Spring Session - Custom Cookie》，spring session在创建session时，是没有设置domain的，那么就会用默认的域名设置。 spring session的开发人员也考虑到了这个，所以在DefaultCookieSerializer（该类是用来处理session的）中设置了一些私有变量和set方法，有domainName和domainNamePattern（正则表达式）等等，domainName是用来设置session的domain，domainNamePattern是用来根据request里的serverName来匹配出对应的domainName。 因为有set方法，我们可以采用注入的方式，在spring session的配置文件中，将domainName或domainNamePattern注入进去 注入domainName方式，可以直接设定对应的顶级域名，比如abc.com123&lt;bean class=\"org.springframework.session.web.http.DefaultCookieSerializer\"&gt; &lt;property name=\"domainName\" value=\"abc.com\"/&gt;&lt;/bean&gt; 注入domainNamePattern方式，可以设定一串正则表达式，用来获取到顶级域名，这里注进去的value值为spring session官方提供的^.+?\\\\.(\\\\w+\\\\.[a-z]+)$，不过我测试时，发现获取不到顶级域名，这个待继续研究，目前项目中可以采取上一种方式直接写死domainName123&lt;bean class=\"org.springframework.session.web.http.DefaultCookieSerializer\"&gt; &lt;property name=\"domainNamePattern\" value=\"^.+?\\\\.(\\\\w+\\\\.[a-z]+)$\"/&gt;&lt;/bean&gt; 这样，最终就解决了二级域名下的session共享问题，之前的关于tomcat的context配置就可以去掉了，因为这里不需要的了 That’s All，也辛辛苦苦写了不少，希望能帮助到大家，如果有问题，还望大家指出，谢谢！","tags":[{"name":"Java","slug":"Java","permalink":"http://lequsun.com/tags/Java/"},{"name":"spring","slug":"spring","permalink":"http://lequsun.com/tags/spring/"},{"name":"session","slug":"session","permalink":"http://lequsun.com/tags/session/"}]},{"title":"Java中关于socket的学习","date":"2016-05-28T04:09:00.000Z","path":"java/java_socket/","text":"前言使用Java这么久，还没有了解过socket呢，只知道是一种可以双向通信的数据交换技术，起源于UNIX，后来各大操作系统都开始支持socket了。于是本人呢，就花些时间学习了一下。所以，直接上代码！ 创建socket处理类 SocketOperate1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStream;import java.net.Socket;/** * Created by SunLeqi on 4/27/2016 */class SocketOperate implements Runnable &#123; private Socket socket; //该线程所处理的Socket所对应的输入流 private BufferedReader br = null; private InputStreamReader reader = null; SocketOperate(Socket socket) throws IOException&#123; this.socket = socket; reader = new InputStreamReader(this.socket.getInputStream(),\"utf-8\"); br = new BufferedReader(reader); &#125; @Override public void run() &#123; try &#123; //采用循环不断从socket中读取客户端发送过来的数据 int i = 0; while (true)&#123; String msg = null; try &#123; msg = br.readLine(); &#125; catch (IOException e1) &#123; br.close(); reader.close(); socket.close(); e1.printStackTrace(); &#125; System.out.println(msg); if (msg == null)&#123; break; &#125; OutputStream os = socket.getOutputStream(); os.write((\"RESPONSE, SUCCESS, Server给Client发来消息了！ \"+ i + \"\\n\").getBytes(\"utf-8\")); os.flush(); i++; &#125; &#125;catch (IOException e2)&#123; e2.printStackTrace(); &#125; &#125;&#125; 新建SocketThread类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;/** * Created by SunLeqi on 4/26/2016 */class SocketThread extends Thread &#123; private ServerSocket serverSocket = null; SocketThread(ServerSocket serverSocket)&#123; try&#123; if(serverSocket == null)&#123; //端口自定义，这里我定为9999 this.serverSocket = new ServerSocket(9999); System.out.println(\"socket start\"); &#125; &#125; catch (Exception e) &#123; System.out.println(\"SocketThread构造方法创建socket服务出错\"); e.printStackTrace(); &#125; &#125; @Override public void run()&#123; //采取死循环处理数据，可以使进程一直维持，接收数据 while (true)&#123; try&#123; if(serverSocket == null)&#123; break; &#125;else if(serverSocket.isClosed())&#123; break; &#125; Socket socket = serverSocket.accept(); if(socket != null &amp;&amp; !socket.isClosed())&#123; //处理接收的数据 Thread t1 = new Thread(new SocketOperate(socket)); t1.start(); &#125; else &#123; break; &#125; &#125;catch (Exception e)&#123; System.out.println(\"SocketThread的run方法创建socket服务出错\"); e.printStackTrace(); &#125; &#125; &#125; //关闭socket服务 void closeSocketServer()&#123; try &#123; if(serverSocket != null &amp;&amp; !serverSocket.isClosed())&#123; serverSocket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 最后在web.xml中配上listener，使项目在启动的时候创建socket线程，开始接收信息123&lt;listener&gt; &lt;listener-class&gt;SocketThreadInitListener&lt;/listener-class&gt;&lt;/listener&gt; 123456789101112131415161718192021222324252627import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;/** * Created by SunLeqi on 4/22/2016 */public class AttendSocketListener implements ServletContextListener &#123; private SocketThread socketThread; @Override public void contextInitialized(ServletContextEvent servletContextEvent) &#123; if(socketThread == null)&#123; //新建线程类 socketThread = new SocketThread(null); //启动线程 socketThread.start(); &#125; &#125; @Override public void contextDestroyed(ServletContextEvent servletContextEvent) &#123; if(socketThread != null &amp;&amp; !socketThread.isInterrupted())&#123; socketThread.closeSocketServer(); socketThread.interrupt(); &#125; &#125;&#125; 以上是socket服务端代码 以下看看客户端代码，这里可以自行采用main方法或者junit来实现，我这里是用junit测试的12345678910111213141516171819202122232425262728293031323334import org.junit.Test;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.Socket;/** * Created by SunLeqi on 4/27/2016 */public class ClientTest &#123; @Test public void test() throws IOException&#123; Socket socket = new Socket(\"127.0.0.1\",9999); PrintWriter os = new PrintWriter(socket.getOutputStream()); BufferedReader is = new BufferedReader(new InputStreamReader(socket.getInputStream())); int i = 1; while (socket.isConnected())&#123; os.print(\"REQUEST, OK, 这条信息来自Socket客户端\"+\"\\n\"); os.flush(); System.out.println(\"Client:\"+i); System.out.println(\"Server:\"+is.readLine()); i++; if(i == 10)&#123; break; &#125; &#125; os.close(); is.close(); socket.close(); &#125;&#125; 基本上，代码就这样了，比较简单，可以点进源码好好了解一下，也可以拓展开，尝试着写个即时通讯工具哦。最后，还得安利一下IDEA，写代码真爽！！！","tags":[{"name":"Java","slug":"Java","permalink":"http://lequsun.com/tags/Java/"},{"name":"socket","slug":"socket","permalink":"http://lequsun.com/tags/socket/"}]},{"title":"Java中的抽象类与接口","date":"2016-05-19T15:35:00.000Z","path":"java/java_interface/","text":"抽象类 抽象类是由abstract修饰的类，并且一定包含有用abstract修饰的方法，也就是抽象方法，当一个类中有抽象方法的时候，这个类一定要被定义成抽象类。 抽象类中也可以没有抽象方法。 抽象类除了有抽象方法，其它的与普通的类没什么区别。 当抽象类作为父类被子类继承时，子类必须实现抽象类父类中的抽象方法，如果没实现的话，则必须将子类也定义为抽象类，父类不为抽象类时，子类也可以为抽象类。 抽象类不能用new操作符来初始化，但是可以定义它的构造方法 接口 接口是一种与类相似的结构，只包含常量和抽象方法，即接口中出现的数据是常量，默认为public static final定义的，方法默认为abstract，可以不写。 一个接口可以扩展一个或多个接口。 一个类只能继承一个类，但是能实现多个接口，从而实现多继承。 接口也不能用new操作符来初始化。 区别 变量 构造方法 方法 抽象类 无限制 子类通过构造方法链调用构造方法，抽象类不能用new操作符实例化 无限制 接口 所有的变量必须是public static final的 没有构造方法，接口不能用new操作符实例化 所有的方法必须是公共的抽象实例方法 设计指南 抽象类和接口都是用来明确多个对象的共同特征的。一般来说，详细描述父子关系的强是关系（strong is-a relationship）应该用类建模。例如，因为公历是一种日历，所以，类java.util.GregorianCalendar和java.util.Calendar是用类继承建模的。弱是关系（weak is-a relationship）也称为类属关系（is-kind-of relationship），它表明对象拥有某种属性。弱是关系可以用接口来建模。例如，所有的字符串都是可比较的，因此，String类实现Comparable接口。","tags":[{"name":"Java","slug":"Java","permalink":"http://lequsun.com/tags/Java/"}]},{"title":"MyEclipse 2014 Java Project转Web Project","date":"2016-05-19T15:10:08.000Z","path":"tool/myeclipse_project/","text":"SVN上check下来一段代码，发现无法部署到Tomcat，原因是该项目为Java Project，应转为Web Project，尝试方法如下： 1、项目上右击，如图选择 2、选中Dynamic Web Module和Java，点OK，Javascript默认已选中，这样就可以部署到Tomcat了，如图：","tags":[{"name":"MyEclipse","slug":"MyEclipse","permalink":"http://lequsun.com/tags/MyEclipse/"},{"name":"Eclipse","slug":"Eclipse","permalink":"http://lequsun.com/tags/Eclipse/"}]}]